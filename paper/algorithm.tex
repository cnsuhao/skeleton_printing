\section{Algorithm}
Let M denote the mesh model, and let S denote the Laplacian skeleton. We propose an algorithm for partitioning S into a minimum set of nice (disjoint) subgraphs, each of which can be fabricated in a 3D printer without using support structures. Decomposing S into two pieces can be done by duplicating a node v and splitting the arcs incident to v properly; however, decomposing M around v requires the determination of the position and normal of a cutting plane; to realize these and guarantee a nice look on the finished surface with shortest seams, we set a constraint of minimizing the peripheral length of a cut.
For realizing the objectives, in addition to the angle constraint for the arcs, we need to consider the dimension constraint: the dimension of the printing model should be within the working space of a given 3D printer.

To summarize, our objectives are the minimization of (1) the number of partitioned components N; (2) the total peripheral length of each cut Li, i.e., .

The constraints of the problem are as follows:
(1) Each arc of the partitioned subgraph of the skeleton subtends to a common axis by an angle of no larger than ?, where ? is defined based on printing experiments without using any support structure. This guarantees that the corresponding mesh component is support-free during the printing process.
(3) Let the normal direction of the cut c (pointing to the exterior of the partitioned part), denoted by n(c); as the directed arcs of Hi are translated to a common origin, they form a fork, the fork has a central ray, which is the middle axis of the minimum cone that encloses the fork, let Cone(Hi) be the cone, let the central ray of Cone(Hi) be denoted as r(Hi); in order to guarantee support-free fabrication for the boundary of the cut, the angle between n(c) and r(Hi) should satisfy A(n(c), r(Hi)) ¡Ü ?/2 + ??.
(3) The base of a printing model should be large enough to gather sticky force from the building platform, such that the model is not deformed during the building process. Formally, let b(Hi) denote the area of the base of the mesh component corresponding to Hi, let ? be a user-defined threshold value., then we have b(Hi) ¡Ý ?. Here ? can be determined by some simple printing experiments.
(4) Each cut partitions a single subgraph.

To summarize, we have the following optimization system:

	Objective: min N and min 	(1)
	Subject to: A(e, r(Hi)) ¡Ü ?, for each e ¡Ê Hi	(2)
	A(n(c), r(Hi)) ¡Ü ?/2+ ?	(3)
	b(Hi) ¡Ý ?	(4)
	c ¡É S = c ¡É Hi	(5)
where Hi is the target subgraph to be cut off.


Assume that we are given a function Tirm_BFS(v, G) which travers G from v in a breath first search manner until all arcs satisfying constraints (2-3) are determined, we have the following algorithm for skeleton decomposition. The main idea of our algorithm is to randomly search the graph using Monte Carlo Method, which randomly chooses a node of S to start traversing and randomly chooses an arc of the current node as the exit path.

Algorithm: $Skeleton_Mesh_Decomposition(S, M)$
Input: The Laplacian skeleton S of a mesh model M;
Output: The decomposition of S into a set of the least pieces of subgraphs T, each arc of which subtends to an axis by an angle of no larger than ?, where (0.5? ? ?) is the minimum angle subtends to the build plate that allows a facet being printed free of support structure.
1.  $T = \oslash$; $min = \inf$; count = 0; $max_iter$ = a user defined large constant;
// initialization

Algorithm: Skeleton_Mesh_Decomposition(S, M)
Input: The Laplacian skeleton S of a mesh model M;
Output: The decomposition of S into a set of the least pieces of subgraphs T, each arc of which subtends to an axis by an angle of no larger than ?, where (0.5? ? ?) is the minimum angle subtends to the build plate that allows a facet being printed free of support structure.
1.  T = ?; min = +¡Þ; count = 0; max_iter = a user defined large constant;
// initialization
2.  while  count < max_iter  do
3.         G = S; U = ?;
4.         while  G ¡Ù ?  do
5.                for  each node v   S  do  // Monte Carlo Method
6.                     H = Trim_BFS(v, S, ?);
7.                     S = S \ H;
8.                     U = U¡ÈH;
9.                     if  ||U|| < min  then
10.                       T = U;
11.                       min = ||U||;
12.        count = count +1;  // one iteration
13.  return  T;


Skeleton Partition:
Next we shall show how Tirm_BFS(v, S, ?) works to find a maximal subgraph starting at v that satisfies the angle constraint. Let H be the current subgraph obtained. When an arc e of G is visited, we need to determine whether it should be included into H. If the start of each outgoing arc of H is moved to a common site, then the arcs form a fork (Figure QAZ). A na?ve method to judge whether e should be included is to move the start of e to the origin of the fork, and compute the angle between e and each arc of the fork, e is included if the maximum angle between e and each arc of the fork does not exceed 0.5?. However, this na?ve method would require O(K2) time, where K is the number of the nodes of S. To speed up this process, we keep the pair of vectors hat form the largest angle and judge whether a new vector expands the mouth of the fork; if so, determine the other vector (may not be an arc of H). See Figure QAZ, let   and   be the units of these two vectors obtained so far, for simplicity, we denoted by F( ,  ) the fork with the starts of all unit vectors converging at the origin of the coordinate frame, where   and  are the pair of unit vectors that form the largest angle in the fork. Let   be the unit of a new vector to be processed next, if   penetrates through the blue circle, then no change need to be made to the fork; otherwise, let Dij denote the spherical disk that passes through the endpoints of   and  , let ci,j be the center of Di,j, let Bi,j be the boundary circle of Di,j, the circle passing through   and ci,j (denoted as O( , ci,j)) intersects Bi,j at two points, let q the point further away from the endpoint of  , then q is the endpoint of the other extreme vector   (in addition to  ) that is used in the next iteration. To summarize,
A new edge ek is taken by Function Tirm_BFS if and only if one of the following two conditions is met:
(1) the angle between   and  , denoted as A( ,  ), satisfies A( ,  ) ¡Ü A( ,  )?
(2) A( ,  ) ¡Ü ??????, where q = O( , ci,j) Bi,j.


[Remove the coordinate axes; change Cij into ci,j]

Figure QAZ: Illustration of unit vectors, unit sphere, spherical disks, and the determination of taking a new edge in Trim_BFS.

Mesh Partition:


[Anton: Optimization of cutting sequence]
Although the skeleton partition tells us a rough sketch of the mesh partition, i.e., the cutting plane should be in the vicinity of each node v incident to two distinct subgraphs. Yet we need to determine the exact positions of the cutting planes. For each node v that is incident to at least two distinct subgraphs Hi and Hj, we process it using the following cutting principle:

The Cutting Scheme for M:
See Figure TJK, at the position of node v, define two fillets each of which contains all planes that orthogonal to the vectors in Cone(Hi) or Cone(Hj), let Fillet(Hi) and Fillet(Hj) be the two fillets respectively. Depending on the relative position of Fillet(Hi) and Fillet(Hj), we have the following cases:
	(Fillet(Hi) ¡É Fillet(Hj)) / {v} ¡Ù ?;
Then randomly sample a set of cutting planes from (Fillet(Hi) ¡É Fillet(Hj)) / {v}, and determine the one achieving the minimum cutting length.
	(Fillet(Hi) ¡É Fillet(Hj)) = {v};
In this case, two cuts c1 and c2 are inevitable in order to separate the mesh, however, care must be taken as the angle between c1 and c2 should be constrained by A(n(c1), n(c2)) ¡Ü ?/2+ ?, i.e., Eq.(5), if this constraint is violated, one more cut in between c1 and c2 is required; while the base of each partitioned component should be constrained by b(Hi) ¡Ý ? and b(Hj) ¡Ý ?, i.e., Eq.(6). If any of the constraints is not satisfied, we shall translate the fillets along the build direction in an opposite sense until the constraints are satisfied (See Figure TJK). In this process, if the translation hits a induce


Figure TJK: Illustration of two fillets incident at a common node.

Let R(v) be the set of reflex vertices on M that are incident to v during the Laplacian shrinking process, we shall truncate R(v) such that the non-significant reflex vertices are removed away. Here, given a vertex vi and any of its neighbor vj, vi is reflex if (vi - vj)(nj - ni) is nonnegative, the significance of a reflex vertex can be quantified as the magnitude of (vi - vj)(nj - ni) [Au_2012].
For each vertex in R(v), we shall process a pair of fillets as done for node v above. Particularly, if v is neighbor to at least three nodes in S while is only neighbored to a single node w in subgraph Hi, then the separation of the mesh component corresponding to Hi may not be feasible if only R(v) is used, this is because the position of v is designed for the purpose of connecting the different branches. To separate the mesh component of Hi, we process arc vw as follows:
Given a user-defined threshold value ?, if ||vw|| ¡Ü??, then R(v) is extended to contain the reflex vertices of M that are incident to w. On the other hand, if ||vw|| > ?, then a partition of the arc vw by an interval of ? is applied. Subsequently, for each node along the arc vw, the above scheme for processing a pair of fillets for node v is exploited, see figure GHJ.
Finally, if the cut constraint (Eq. (7)) is violated, a sequence of iterative cutting is required.


Figure GHJ: 2D illustration editing a long arc for cutting.

Cut-subgraph Intersection Detection: In order to take care of Eq. (7), the intersections of a cut and the subgraphs can be efficiently determined by taking advantage of the correspondence between the mesh vertices and the skeleton nodes: each vertex of M is mapped to a single node of S. Therefore, as a cut goes through the mesh surface, the endpoints of the cut edges of M lend us the information of the cut subgraphs. Approximately, if a cut c goes into an edge whose endpoints are incident to a subgraph H, then c cuts H.

Tirm_BFS($v$, $S$,$\theta$)
Input: A node v of Laplacian skeleton S, an angular value ?.
Output: A maximal subgraph H rooted at v and its corresponding mesh component that meet the constraints (2-7).
1. starting from v, initialize F( ,  ), H = ?;
2. for  the current arc ek of S picked by the BFS process  do
3.     if  A( ,  ) ¡Ü A( ,  )  then  goto  line 10;
4.     else
5.          q = O( , ci,j) Bi,j;
6.          if  A( ,  ) ¡Ü ??????  then
7.               =  ;
8.               =  ;
9.             update Bi,j and ci,j;
10.            H = H ¡È {ek};
11. call the cutting scheme for M;
12. M= M/MH;  // remove MH from M
13. return  H and MH;

In line 2 of Tirm_BFS, the BFS process randomly chooses an arc incident to v to proceed on. In order to guarantee a greater chance of converging to the optimal result in a short time, we apply a training-and-learning procedure for the first 1000 runs. Formally, let Nv be the number of times an arc e is chosen as the exit arc when node v is visited. Given the data of the first 1000 runs, as a node v is visited, the probability of choosing an arc e as an outgoing arc in the subsequent runs is,

	P(v, e) = Nv/1000	(7)

To further speed up the process of Trim_BFS, we assign a mark that stores the minimum number of subgraphs obtained so far, such that the current branching can be terminated if its output number of subgraphs is larger than the mark.

Since the traversing process assigns a specific direction to each arc that was originally undirected in S., it is not obvious whether the angle constraint is satisfied, To clarify this, we provide the following lemma.

Lemma 1: H = Tirm_BFS(v, G, ?) is a maximal subgraph of G that satisfies the angle constraint, i.e., each arc of H subtends to an axis by an angle of no larger than ?.

Proof: Suppose to the contrary that H violates the angle constraint, there exists a directed arc that does not satisfy the angle constraint. For example, directed arc (c, a) or directed arc (b, c) in Figure WSX. Such case is impossible as Line 3 and Line 6 of function Trim_BFS excludes any directed arc that violates the angle constraint of nor larger than ? with respect to the (virtual) center axis.
It remains to prove that H is maximal, i.e., the largest graph rooted at v that covers all the arcs that satisfies the angle constraint. Suppose that this is not true, there must exist an arc that was mistakenly discarded due to the direction in which the arc is traversed. Let (b, c) be one of such arcs, as illustrated in Figure WSX (a). When the arc is directed from b to c, it is not included as it violates the angle constraint, but can be included if the arc directed from c to b. We shall prove in a case-by-case basis.
If c is not reachable from v via a directed path passing through b (Figure WSX (c)), then c is only reachable from b, arc (b, c) should not be included and line 6 of Function Trim_BFS correctly handle this case.
Otherwise, c is reachable from v via a directed path without passing through b (Figure WSX (d)). As c is visited, by Line 2 of Function Trim_BFS, each arc leaving c is considered, and the directed arc (c, b) is correctly included into H. This completes the proof. ¡õ



                   (a)                      (b)

Figure WSX: Illustration of the inclusion of a directed arc into a maximal subgraph by Trim_BFS.





\section{Algorithm}
\textbf{Skeleton Partition.} Let $M$ denote the mesh model, and let S denote the Laplacian skeleton obtained via \cite{AuTCCL08}. We propose an algorithm for partitioning S into a minimum set of \emph{disjoint} subgraphs, each of which can be fabricated in a 3D printer without using support structures. Decomposing S into two pieces can be done by duplicating a node $v$; and partitioning $M$ at node $v$ requires the determination of the position and normal of a cutting plane. To guarantee an aesthetical look on the resulting surface with shortest seams, we need a constraint to minimize the peripheral length of the cut in terms of the position and normal of the cutting plane. Note that the orientation of the cutting plane affects the printing direction and thus the shape of the subgraph while on the contrary, the shape of the subgraph limits the orientation of the cutting plane. Hence, this is an essential \emph{chicken-and-egg} problem. In addition, we also need to consider the printing volume constraint, i.e., the volume of the printing model should be within the working volume of a given 3{D} printer.

To summarize, our objectives are the minimization of: (1) the number of partitioned components $N$; (2) the total peripheral length of each cut $L_i$, i.e., $\Sigma L_i$. The constraints of the problem are as follows:
(i) Each arc of the partitioned subgraph $H_i$ subtends to an axis by an angle of no larger than $\theta$, where $\theta$ is a printer-dependent parameter obtained from experiments. This guarantees that the corresponding mesh component is support-free during the printing process;
(ii) Let the normal direction of the cut $c$ (pointing to the exterior of the partitioned part) be denoted as $n(c)$; as the directed arcs of $H_i$ are translated to a common origin, they form a fork, the fork has a central ray, which is the middle axis of the minimum cone that encloses the fork (see Figure \ref{fig:sphere}), let $cone(H_i)$ be the cone, let the central ray of $cone(H_i)$ be denoted as $r(H_i)$; in order to guarantee support-free fabrication for the boundary of the cut, the angle between $n(c)$ and $r(H_i)$ should satisfy: $angle(n(c), r(Hi)) \leq \pi/2 + \theta$;
(iii) The base of a printing model should be large enough to gather sticky force from the building platform, such that the model is not deformed during the building process. Formally, let $b(H_i)$ denote the area of the base of the mesh component corresponding to $H_i$, which is approximately equal to the peripheral length of the base times the thickness of the shell. let $\tau$ be a user-defined threshold value., then we have $b(H_i) \geq \tau$. Here $\tau$ can be determined empirically; Finally,
(iv) Each cut partitions a single subgraph.

We have the following optimization system:
\begin{equation*}
\begin{aligned}
& \underset{x}{\text{minimize}} \quad N \quad \text{and} \quad \sum_{i=1}^N{L_i},
\quad \text{subject to:} \\
& A(e, r(H_i)) \leq \theta, \; i = 1, \ldots, m, \forall e \in H_i, & (1)\\
& A(n(c), r(H_i)) \leq \pi/2+ \theta, & (2)\\
& b(H_i) \geq \tau, & (3)\\
& c \cap S = c \cap H_i, & (4)
\end{aligned}
\end{equation*}
where all $H_i$-s constitute a partition of the original graph to be cut off. A direct exploration of all possible partitions over the graph $G$ could quickly leads to exponential complexity. The key here is to quickly explore potential good partitions in a way that subsequent exploration of the graph is limited to those which leads to a less value of the optimization function. Hence, we employ a randomized Monte Carlo algorithm.

The idea is to separate the minimization of the two target terms (number of subgraphs and the total cutting length) sequentially rather than simultaneously. To minimize the number of subgraphs, we use a randomized exploration strategy, but give a higher probability to explore the graph deeply. In particular, assume that we are given a function $Tirm\_BFS(v, G, \theta)$ which traverses $G$ from $v$ in a breath first search manner to progressively collect arcs which satisfy constraints (2-3). The following algorithm sketches the idea of the skeleton decomposition algorithm. The main idea is to randomly search for candidate subgraphs using Monte Carlo Method, which randomly chooses a node of $G$ to start traversing and randomly grows the subgraph while paying attention to the constraints.

\begin{algorithm}
\caption{$SkeletonMeshDecomposition(S, M)$}
\label{alg:Framwork}
\begin{algorithmic}[1]
\REQUIRE~
The Laplacian skeleton $S$ of a mesh model $M$;
\ENSURE~
The decomposition of $S$ into a set of the least pieces of subgraphs $T$, each arc of which subtends to an axis by an angle of no larger than $\theta$;
\STATE $T = \emptyset$; $min = \inf$; $count$ = 0; $max_iter$ = a user defined large constant;
\WHILE {$count < max_iter$}
\STATE  $G=S$; $U= \emptyset$;
\WHILE {$G\neq \emptyset$}
\FOR{$i=1$; $i<| S |$; $i++$ }
\STATE $H = Trim\_BFS(v_i, G, \theta)$;
\STATE $H = S / H$;
\STATE $U = U \cup H$;
\IF {$| U | < min$}
\STATE $T = U$;
\STATE  $min = | U | $;
\ENDIF
\ENDFOR
\ENDWHILE
\STATE $count =count + 1$;
\ENDWHILE
\label{code:fram:select} \\
\RETURN $T$;
\end{algorithmic}
\end{algorithm}

\begin{figure}[tbp]
  \centering
  \includegraphics[width=0.4\textwidth]{figs/take_arc.png}
  \caption{\label{fig:sphere}%
           Illustration of unit vectors, unit sphere, spherical disks, and the determination of taking a new edge in $TrimBFS$.}
\end{figure}

Next we shall show how $Tirm\_BFS(v, G, \theta)$ works to find a locally maximal subgraph starting at $v$ that satisfies the angle constraint. Let $H$ be the current subgraph obtained so far. When an arc $e$ of $G$ is visited, we need to determine whether it should be included into $H$. If the start of each outgoing arc of $H$ is moved to a common origin, then the arcs form a fork of rays (Figure \ref{fig:sphere}). A naive method to judge whether $e$ should be included is to move the start of $e$ to the origin of the fork, and compute the angle between $e$ and each arc of the fork, $e$ is included if the maximum angle between $e$ and each arc of the fork does not exceed $\pi/2$. However, this would lead to $O(K^{2})$ time complexity, where $K$ is the size of $S$. To speed up this process, we keep the pair of vectors which form the largest angle and judge whether a new vector expands the angle of the fork. See in Figure \ref{fig:sphere}, let $\hat{e_i}$  and $\hat{e_j}$ be the units of these two vectors obtained so far. For simplicity, we denoted by $F( \hat{e_i}, \hat{e_j} )$ the fork with the starts of all unit vectors converging at the origin of the coordinate frame, where $\hat{e_i}$  and  $\hat{e_j}$  are the pair of unit vectors that form the largest angle in the fork. Let $\hat{e_k}$  be the unit of a new vector to be processed next, if $\hat{e_k}$ penetrates through the blue circle, then no change need to be made to the fork; otherwise, let $D_{i,j}$ denote the spherical disk that passes through the endpoints of $\hat{e_i}$  and $\hat{e_j}$ whose central axis is collinear with $\hat{e_i}$  + $\hat{e_j}$, let $c_{i,j}$ be the center of $D_{i,j}$, let $B_{i,j}$ be the boundary circle of $D_{i,j}$. The circle passing through $\hat{e_k}$  and $c_{i,j}$, denoted as $O( \hat{e_k}, c_{i,j})$, intersects  $B_{i,j}$ at two points, let $q$ the point further away from the endpoint of $\hat{e_k}$, then $\overrightarrow{oq}$ and $\hat{e_k}$ are the two extreme vectors that to be used in the next iteration. To summarize, a new arc $e_k$ is taken by Function $Tirm\_BFS$ if and only if one of the following two conditions is met:
(1) the angle between $\overrightarrow{oc_{i,j}}$ and $\hat{e_k}$, denoted as $A(\overrightarrow{oc_{i,j}}, \hat{e_k})$, satisfies  $A(\overrightarrow{oc_{i,j}}, \hat{e_k}) \leq A(\overrightarrow{oc_{i,j}}, \hat{e_i})$;
(2) $A(\overrightarrow{oc_{i,j}}, \hat{e_k})  \leq \pi - 2\theta$, where $q = O( \hat{e_k}, c_{i,j}) \cap B_{i,j}$.


\begin{algorithm}[h]
\caption{Algorithm: $Tirm\_BFS(v, S,\theta)$}
\label{alg:trim}
\begin{algorithmic}[1]
\REQUIRE~
A node $v$ of Laplacian skeleton $S$, an angular value $\theta$.
\ENSURE~
 A maximal subgraph $H$ rooted at $v$ and its corresponding mesh component that meet the constraints $(Eq.1-4)$.
\STATE starting from $v$, initialize F($\hat{e_i}$, $\hat{e_j}$); $H = \emptyset $;
\WHILE  {the current arc $e_k$ of $S$ picked by the BFS process is not empty}
  \IF  {$A(\overrightarrow{oc_{i,j}},  \hat{e_k}) \leq A(\overrightarrow{oc_{i,j}},  \hat{e_i})$}
  \STATE  $H = H \cup {e_k}$;
  \ELSIF {$A(\overrightarrow{oq},  \hat{e_k}) \leq \pi- 2\theta$}
  \STATE $q = O( \hat{e_k}, c_{i,j}) \cap B_{i,j}$;
%  \IF  {$A(\overrightarrow{oq},  \hat{e_k}) \leq \pi- 2\theta$}
  \STATE  $\hat{e_i}=  \hat{e_k}$;
  \STATE $\hat{e_j} =  \overrightarrow{oq}$;
  \STATE  update $B_{i,j}$ and $c_{i,j}$;
  \STATE  $H = H \cup {e_k}$;
  \ENDIF
\ENDWHILE
\STATE  call the cutting scheme for $M$;
\STATE  $M= M/M_H$;
\label{code:fram:select} \\
\RETURN  $H$ and $M_H$;
\end{algorithmic}
\end{algorithm}

Algorithm \ref{alg:trim} demonstrates the growing process. As the order of the chosen arcs influences the shape of the final BFS subgraph, in line $2$, the BFS process randomly chooses an arc incident to $v$ to proceed on. In order to guarantee a greater chance of converging to the optimal result in a short time, we apply a training-and-learning procedure for the first $k$ (say $1000$) runs. Formally, let $N_v$ be the number of times an arc is chosen as the exit arc when node $v$ is visited. Given the data of the first $k$ runs, as a node $v$ is visited, the probability of choosing an arc $e$ as an outgoing arc in the subsequent runs is, $P(v, e) = N_v/k$. To further speed up the process of $Trim\_BFS$, we assign a mark that stores the minimum number of subgraphs obtained so far, such that the current branching can be terminated if its output number of subgraphs is larger than the mark. Further, as the grow of $Trim\_BFS$ is greedy thus the growth is towards a maximal subgraph that satisfies the angle constraints, the resulting partition of Algorithm \ref{alg:Framwork} might not be a global optimum. In order to ensure more possibilities to find a global optimum, we employ a probability-based exploring scheme. In particular, we set the probability of stop the growing of $Trim\_BFS$ as $k/K$ where $k$ is the size of the current subgraph and $K$ is the size of $S$. This gives high probability for the $Trim\_BFS$ to grow in larger sizes while also rises the probability of exploring subgraphs of smaller sizes. We implement it using rejection sampling.

%Since the traversing process assigns a specific direction to each arc that was originally undirected in $S$, it is not obvious whether the angle constraint is satisfied, To clarify this, we provide the following lemma.


%\begin{figure}[t]
%  \centering
%  \mbox{} \hfill
%  \includegraphics[width=0.4\textwidth]{figs/proof.png}
%  \caption{\label{fig:proof}%
%           Illustration of taking a directed arc into a maximal subgraph by $Trim\_BFS$.}
%\end{figure}



%\emph{Lemma 1}: $H = Tirm\_BFS(v, G, \theta)$ is a maximal subgraph of $G$ that satisfies the angle constraint, i.e., each arc of $H$ subtends to an axis by an angle of no larger than $\theta$.


%\emph{Proof}: Suppose to the contrary that $H$ violates the angle constraint, there exists a directed arc that does not satisfy the angle constraint. For example, arc $\overrightarrow{ca}$ or arc $\overrightarrow{bc}$ in Figure \ref{fig:proof}. Such case is impossible as Line $3$ and Line $6$ of function $Trim\_BFS$ excludes any directed arc that violates the angle constraint of no larger than $\theta$ with respect to the (virtual) central axis.It remains to prove that $H$ is maximal, i.e., the largest graph rooted at $v$ that covers all the arcs that satisfies the angle constraint. Suppose that this is not true, there must exist an arc that was mistakenly discarded due to the direction in which the arc is traversed. Let $(b, c)$ be one of such arcs, as illustrated in Figure \ref{fig:proof}(a). When the arc is directed from $b$ to $c$, it is not included as it violates the angle constraint, but can be included if the arc directed from $c$ to $b$. We shall prove in a case-by-case basis. If $c$ is not reachable from $v$ via a directed path passing through $b$ (Figure \ref{fig:proof} (c)), then $c$ is only reachable from $b$, arc $bc$ should not be included and line 6 of Function $Trim\_BFS$ correctly handle this case. Otherwise, $c$ is reachable from $v$ via a directed path without passing through $b$ (Figure \ref{fig:proof} (d)). As $c$ is visited, by Line 2 of Function $Trim\_BFS$, each arc leaving $c$ is considered, and $\overrightarrow{cb}$ is correctly included into $H$. This completes the proof.



\begin{figure}[t]
  \centering
  \mbox{} \hfill
  \includegraphics[width=0.3\textwidth]{figs/cone-fillet.png}
  \caption{\label{fig:fillets}%
           Illustration of a cone and its corresponding fillets, where two cutting planes in $F(H_i)$ and their associated vectors in $cone(H_i)$ are marked by distinct colors.}
\end{figure}


\textbf{Mesh Partition.} The skeleton partition tells us a rough sketch of the mesh partition, i.e., the cutting plane should be in the vicinity of each node $v$ incident to two distinct subgraphs. Yet we need to determine the exact positions and orientations of the cutting planes. For each node $v$ that is incident to at least two distinct subgraphs $H_i$ and $H_j$, we process it using the following cutting principle.


In Figure \ref{fig:fillets}, at the position of node $v$, we want to find a surface vertex $q \in M$ around $v$ which the cutting plane should pass through, yet the cutting length is minimized. Let us denote the set of all planes which pass through a surface vertex $p$ and are orthogonal to vectors in $cone(H_i)$ (originated from $p$)  as $F(H_i)$, which we term as a \emph{fillet}. Then if the node $v$ is incident to two subgraphs $H_1$ and $H_j$, we have two plane sets $F(H_i)$ and $F(H_j)$ at point $p$, respectively. Depending on the relative position of $p$, we have the following two cases: \emph{case (i)} $F(H_i) \cap F(H_j) \neq \emptyset$. In this case, we shall randomly sample a set of cutting planes from $F(H_i) \cap F(H_j)$, and determine the one achieving the minimum cutting length; \emph{case (ii):} $F(H_i) \cap F(H_j) = \emptyset$. In this case, two cuts are required in order to separate the mesh into support-free subparts, however, care must be taken as the angle between $c_1$ and $c_2$ should be constrained by $A(n(c_1), n(c_2)) \leq \pi/2+ \theta$. If this constraint is violated, one more cut in between $c_1$ and $c_2$ is required; while the base of each partitioned component should be constrained by $b(H_i) \geq \tau$ and $b(H_j) \geq \tau$. If any of the constraints is not satisfied, we shall translate the fillets along the opposite printing direction until the constraints are satisfied.


In either case, a cut that nicely follows the geometry features is demanded to preserve aesthetic appearance in the final assembled object. However, the positions of the skeleton nodes may not locally reflect the geometric features such as concave areas on the mesh surface, therefore they maybe insufficient for a nice partition of the mesh. To compensate this, we exploit the concave vertices of the mesh that are incident to the skeleton nodes and take those that significantly concave into a candidate set of pivots for the cuts. More precisely, let $R(v)$ be the set of concave vertices on $M$ that are incident to $v$ during the Laplacian shrinking process \cite{AuTCCL08}, we truncate $R(v)$ such that the non-significant concave vertices are removed away. Here, given a vertex $v_i$ and any of its neighbor $v_j$, $v_i$ is concave if $(v_i - v_j)(n_j - n_i)$ is nonnegative, the significance of a concave vertex can be quantified as the magnitude of $(v_i - v_j)(n_j - n_i)$ \cite{au2012mesh}, denoted as $\tau_i$. We collect vertices whose $\tau_i$ is greater than a threshold $\delta$.  See Figure \ref{fig:fillets}(c-d), for each vertex in $R(v)$, we shall process a pair of fillets as done for vertex $p$ above.


Next, we proceed to find a cutting plane around $v$. We first extend the region $R(v)$ by merging all $R(u)$ where $u$ is an adjacent node of $v$ in $S$. Given all concave vertices in the new $R(v)$, each concave vertex defines a set of feasible cutting planes in accordance to its $fillet$. By feasible we require that the cutting plane does not cut through other subgraph except for $H_i$. We then exhaustively go through all feasible cutting planes and find the one whose cutting length is minimized. In cases of cylindrical parts which do not merit good concaveness, we reduce the threshold value $\delta$ by half and repeat the process until a feasible minimal length cutting plane is found. Figure \ref{fig:forward_tracing} is an illustration of the above process.


%Particularly, if $v$ is a leaf node that is merely neighbored to a single node $w$ in subgraph $H_i$, then the separation of the mesh component corresponding to $H_i$ may not be feasible if merely $R(v)$ is used, this is because the position of $v$ is chosen irrespective of the geometric features of the mesh. To separate the mesh component of $H_i$, we process arc $vw$ as follows: Given a user-defined threshold value $\delta$, if $| vw | \leq \delta$, then $R(v)$ is extended to contain the concave vertices of $M$ that are incident to $w$. On the other hand, if $| vw | > \delta$, then a partition of the arc $vw$ by an interval of $\delta$ is carried out. Subsequently, for each node along arc $vw$, the above scheme for processing node $v$ is exploited, see Figure \ref{fig:forward_tracing}. In this process, the tracing of the nodes along $vw$ stops as a cut does not intersect into any other subgraph other than $H_i$. The technique for detecting the intersection is as follows:

In order to detect whether a cutting plane cut through any subgraph other than $H_i$, we take advantage of the correspondence between the mesh vertices and the skeleton nodes. Since each vertex of $M$ is mapped to a single node of $S$ \cite{AuTCCL08}, as a cut goes through the mesh surface, the endpoints of the cut edges of $M$ give us the information of the cut through. Approximately, if a cut $c$ goes into an edge whose endpoints are incident to a subgraph $H_j$, then $c$ cuts through $H_j$.

%On the other hand, if $v$ is an internal node to at least two subgraphs, see Figure \ref{fig:cross}, then a partition of one subgraph around $v$ is inevitable. The partition scheme follows from the operations on the fillets.





\begin{figure}[tbp]
  \centering
  \mbox{} \hfill
  \includegraphics[width=0.4\textwidth]{figs/forward_tracing.png}
  \caption{\label{fig:forward_tracing}%
           2D illustration of R(v) and the cuts, all vertices in R(v) are shown in green, and the cuts associated with a vertex are shown in dashed lines:(a) the case of cuts around concave points; (b) the case of cuts on a cylindrical part.}
\end{figure}


Sometimes, it is possible for a mesh component which is not printable free of support even though its corresponding skeleton is detected to be printable free of support. This is because the skeleton piece that shares a junction node with any other subgraph may compromise its topology locally \cite{AuTCCL08}, and therefore cannot precisely describe the local topology feature of the partitioned component. In this case, we search along the skeleton and further partition it with an additional cut. Refer to Figure \ref{fig:arm} for an illustration. Empirically, we found this rarely happened.

\begin{figure}[tbp]
  \centering
  \mbox{} \hfill
  \includegraphics[width=0.3\textwidth]{figs/arm.png}
  \caption{\label{fig:arm}%
           Illustration of a mesh component with an overhange that requires support while its corresponding skeleton is support-free}
\end{figure}

%Finally, if the cut-subgraph constraint (Eq. (5)) is violated, a sequence of iterative cutting is required.








